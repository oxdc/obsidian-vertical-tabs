name: Process Release and Upload

on:
  workflow_dispatch:
    inputs:
      tag:
        description: "Tag to process"
        required: true
        type: string
      batch_count:
        description: "Number of mangled variants to generate"
        required: false
        default: "1"
        type: string
      identities:
        description: "Comma-separated list of user identities for reproducible mangling (must match batch_count)"
        required: false
        type: string
      job_id:
        description: "Job ID for tracking purposes"
        required: false
        type: string
  repository_dispatch:
    types: [process-release]
  release:
    types: [published]

jobs:
  process_release:
    runs-on: ubuntu-22.04
    steps:
      - name: Check out repository
        uses: actions/checkout@v4
  
      - name: Set tag and batch count variables
        run: |
          echo "Processing tag and batch count"
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "TAG=${{ github.event.inputs.tag }}" >> $GITHUB_ENV
            echo "BATCH_COUNT=${{ github.event.inputs.batch_count }}" >> $GITHUB_ENV
            echo "IDENTITIES=${{ github.event.inputs.identities }}" >> $GITHUB_ENV
            echo "JOB_ID=${{ github.event.inputs.job_id }}" >> $GITHUB_ENV
          elif [ "${{ github.event_name }}" == "repository_dispatch" ]; then
            echo "TAG=${{ github.event.client_payload.tag }}" >> $GITHUB_ENV
            echo "BATCH_COUNT=${{ github.event.client_payload.batch_count || '1' }}" >> $GITHUB_ENV
            echo "IDENTITIES=${{ github.event.client_payload.identities }}" >> $GITHUB_ENV
            echo "JOB_ID=${{ github.event.client_payload.job_id }}" >> $GITHUB_ENV
          elif [ "${{ github.event_name }}" == "release" ]; then
            echo "TAG=${{ github.event.release.tag_name }}" >> $GITHUB_ENV
            echo "BATCH_COUNT=1" >> $GITHUB_ENV
            echo "IDENTITIES=" >> $GITHUB_ENV
            echo "JOB_ID=" >> $GITHUB_ENV
          fi

      - name: Get commit hash
        run: |
          echo "Getting commit hash for tag: $TAG"
          
          if [ -z "$TAG" ]; then
            echo "Warning: No tag provided, setting commit hash to unknown"
            COMMIT_HASH="unknown"
          else
            # Try to get commit hash from the tag
            if COMMIT_HASH=$(git rev-parse "$TAG^{commit}" 2>/dev/null); then
              echo "Successfully resolved commit hash for tag $TAG: $COMMIT_HASH"
            elif COMMIT_HASH=$(git rev-parse "$TAG" 2>/dev/null); then
              echo "Successfully resolved commit hash for tag $TAG: $COMMIT_HASH"
            else
              echo "Warning: Could not resolve commit hash for tag $TAG, setting to unknown"
              COMMIT_HASH="unknown"
            fi
          fi
          
          echo "COMMIT_HASH=$COMMIT_HASH" >> $GITHUB_ENV
          echo "Final commit hash: $COMMIT_HASH"

      - name: Install jq for JSON processing
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Download release files
        run: |
          # Create dist directory
          mkdir -p ./dist

          # Get release information using Gitea API
          echo "Fetching release information for tag: $TAG"
          release_info=$(curl -s \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/json" \
            "${{ github.server_url }}/api/v1/repos/${{ github.repository }}/releases/tags/$TAG")
          
          echo "Release info response: $release_info"
          
          # Extract release ID
          release_id=$(echo "$release_info" | jq -r '.id // empty')
          echo "Release ID: $release_id"

          if [ -z "$release_id" ]; then
            echo "Error: Could not find release ID for tag $TAG"
            exit 1
          fi

          # Download release assets
          assets_info=$(curl -s \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/json" \
            "${{ github.server_url }}/api/v1/repos/${{ github.repository }}/releases/$release_id/assets")

          echo "Assets info: $assets_info"

          # Parse and download each asset using jq
          echo "$assets_info" | jq -r '.[] | .browser_download_url' | while read -r url; do
            if [ ! -z "$url" ]; then
              filename=$(basename "$url")
              echo "Downloading $filename from $url"
              
              # Download with proper authentication and error handling
              if curl -f -L -o "./dist/$filename" \
                -H "Authorization: token ${{ secrets.RELEASE_TOKEN }}" \
                -H "Accept: application/octet-stream" \
                "$url"; then
                echo "Successfully downloaded $filename"
                
                # Verify file size
                file_size=$(stat -c%s "./dist/$filename" 2>/dev/null || stat -f%z "./dist/$filename" 2>/dev/null || echo "0")
                echo "$filename size: $file_size bytes"
                
                if [ "$file_size" -eq 0 ]; then
                  echo "Error: $filename is empty ($file_size bytes), likely a download error"
                  exit 1
                fi
              else
                echo "Failed to download $filename"
                exit 1
              fi
            fi
          done

          # List downloaded files with sizes
          echo "Downloaded files:"
          ls -la ./dist/

      - name: Verify file integrity
        run: |
          echo "Verifying file integrity using SHA256 hashes..."
          
          # Check each .sha256 file and verify corresponding file
          for sha_file in ./dist/*.sha256; do
            if [ -f "$sha_file" ]; then
              # Get the base filename without .sha256 extension
              base_file="${sha_file%.sha256}"
              filename=$(basename "$base_file")
              
              if [ -f "$base_file" ]; then
                # Read expected hash from .sha256 file
                expected_hash=$(cat "$sha_file" | tr -d '\n\r')
                
                # Calculate actual hash of the file
                actual_hash=$(sha256sum "$base_file" | cut -d' ' -f1)
                
                echo "Verifying $filename:"
                echo "  Expected: $expected_hash"
                echo "  Actual:   $actual_hash"
                
                if [ "$expected_hash" = "$actual_hash" ]; then
                  echo "  ✓ Hash verification passed for $filename"
                else
                  echo "  ✗ Hash verification failed for $filename"
                  echo "Error: File integrity check failed for $filename"
                  exit 1
                fi
              else
                echo "Error: File $base_file not found for hash verification"
                exit 1
              fi
            fi
          done
          
          echo "All file integrity checks passed!"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Set up Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: 1.2.21

      - name: Install dependencies
        run: bun ci

      - name: Validate identities parameter
        run: |
          echo "Validating identities parameter..."
          
          # Parse identities if provided
          if [ ! -z "$IDENTITIES" ]; then
            # Convert comma-separated string to array and count
            IFS=',' read -ra IDENTITY_ARRAY <<< "$IDENTITIES"
            IDENTITY_COUNT=${#IDENTITY_ARRAY[@]}
            
            echo "Provided identities: ${IDENTITY_ARRAY[*]}"
            echo "Identity count: $IDENTITY_COUNT"
            echo "Batch count: $BATCH_COUNT"
            
            # Validate that identity count matches batch count
            if [ "$IDENTITY_COUNT" -ne "$BATCH_COUNT" ]; then
              echo "Error: Number of identities ($IDENTITY_COUNT) must match batch_count ($BATCH_COUNT)"
              exit 1
            fi
          else
            echo "No identities provided, will use random seeds"
          fi

      - name: Run mangling process
        run: |
          # Check if main.js exists
          if [ ! -f "dist/main.js" ]; then
            echo "Error: dist/main.js not found"
            exit 1
          fi
          
          echo "Generating $BATCH_COUNT mangled variants..."
          
          # Run mangling process with identities if provided
          if [ ! -z "$IDENTITIES" ]; then
            echo "Using provided identities: $IDENTITIES"
            mangle_output=$(bun run mangle.mjs "dist/main.js" "$BATCH_COUNT" "$IDENTITIES" "$TAG" "$COMMIT_HASH")
          else
            echo "Using random seeds"
            mangle_output=$(bun run mangle.mjs "dist/main.js" "$BATCH_COUNT" null "$TAG" "$COMMIT_HASH")
          fi
          echo "Mangling output: $mangle_output"
          
          # Extract and validate JSON using jq
          json_results=$(echo "$mangle_output" | grep '^\[' | jq '.')
          if [ $? -ne 0 ]; then
            echo "Error: Invalid JSON output from mangle.mjs"
            exit 1
          fi
                    
          # Verify each generated file using jq
          echo "$json_results" | jq -r '.[] | .filename' | while read -r filename; do
            if [ -f "$filename" ]; then
              echo "✓ Generated file: $filename"
              
              # Get expected hash using jq
              expected_hash=$(echo "$json_results" | jq -r --arg fname "$filename" '.[] | select(.filename == $fname) | .hash')
              
              # Calculate actual hash
              actual_hash=$(sha256sum "$filename" | cut -d' ' -f1)
              
              if [ "$expected_hash" = "$actual_hash" ]; then
                echo "✓ Hash verified for $filename: $expected_hash"
              else
                echo "Error: Hash mismatch for $filename"
                echo "Expected: $expected_hash"
                echo "Actual:   $actual_hash"
                exit 1
              fi
            else
              echo "Error: Expected file $filename not found"
              exit 1
            fi
          done
          
          echo "All $BATCH_COUNT mangled variants generated and verified successfully"

      - name: Setup signing key
        env:
          SIGNING_KEY: ${{ secrets.SIGNING_PRIVATE_KEY }}
        run: |
          if [ ! -z "$SIGNING_KEY" ]; then
            echo "Setting up Ed25519 private key for signing..."
            echo "$SIGNING_KEY" > private_key.pem
            chmod 600 private_key.pem
            echo "Private key file created successfully"
          else
            echo "No signing key provided, archives will not be signed"
          fi

      - name: Initialize upload session
        env:
          SERVER_URL: ${{ secrets.SERVER_URL }}
          AUTH_TOKEN: ${{ secrets.AUTH_TOKEN }}
        run: |
          echo "Initializing upload session..."
          echo "Job ID: $JOB_ID"
          echo "Expected count: $BATCH_COUNT"
          
          response=$(curl -s -X POST "$SERVER_URL/sessions/init" \
            -H "Authorization: Bearer $AUTH_TOKEN" \
            -H "Content-Type: application/json" \
            -H "X-JOB-ID: $JOB_ID" \
            -H "X-EXPECTED-COUNT: $BATCH_COUNT")
          
          echo "Init response: $response"
          
          # Check if response indicates success
          if echo "$response" | jq -e '.success' > /dev/null 2>&1; then
            success=$(echo "$response" | jq -r '.success')
            if [ "$success" != "true" ]; then
              echo "Error: Session initialization failed"
              echo "$response" | jq -r '.error // "Unknown error"'
              exit 1
            fi
          else
            echo "Error: Invalid response format from session initialization"
            echo "$response"
            exit 1
          fi
          
          # Extract UUID from response using jq
          SESSION_UUID=$(echo "$response" | jq -r '.uuid // empty')
          if [ -z "$SESSION_UUID" ]; then
            echo "Error: Failed to extract session UUID from response"
            exit 1
          fi
          echo "SESSION_UUID=$SESSION_UUID" >> $GITHUB_ENV
          echo "Session UUID: $SESSION_UUID"

      - name: Create compressed archives
        env:
          SIGNING_KEY: ${{ secrets.SIGNING_PRIVATE_KEY }}
        run: |
          echo "Creating $BATCH_COUNT compressed archives of release files..."
          
          # Create temporary directory for archive preparation
          mkdir -p temp_archive
          
          # Copy non-main.js files to temp directory (excluding .sha256 files)
          cd dist
          for file in *; do
            if [[ "$file" != "main"* && "$file" != *.sha256 ]]; then
              cp "$file" "../temp_archive/"
            fi
          done
          cd ..
          
          # Create multiple archives, each with a different mangled main.js
          for i in $(seq 1 $BATCH_COUNT); do
            echo "Creating archive $i/$BATCH_COUNT..."
            
            # Copy the mangled main file as main.js in temp directory
            cp "dist/main-$i.js" "temp_archive/main.js"
            
            # Update manifest.json for this archive
            if [ ! -z "$SIGNING_KEY" ]; then
              echo "Signing manifest with Ed25519 private key..."
              bun run update-manifest.mjs "temp_archive" "private_key.pem"
            else
              echo "No signing key provided, skipping signature generation..."
              bun run update-manifest.mjs "temp_archive"
            fi
            
            # Create archive
            cd temp_archive
            zip -r "../release-$TAG-$i.zip" .
            cd ..
            
            # Calculate hash of the archive
            archive_hash=$(sha256sum "release-$TAG-$i.zip" | cut -d' ' -f1)
            echo "ARCHIVE_HASH_$i=$archive_hash" >> $GITHUB_ENV
            echo "Archive $i hash: $archive_hash"
            
            # List contents of archive
            echo "Archive $i contents:"
            unzip -l "release-$TAG-$i.zip"
          done
          
          # Clean up temp directory
          rm -rf temp_archive
          
          echo "All $BATCH_COUNT archives created successfully"
          
          # Clean up private key file
          if [ -f "private_key.pem" ]; then
            rm -f private_key.pem
            echo "Private key file cleaned up"
          fi

      - name: Upload compressed archives to server
        env:
          SERVER_URL: ${{ secrets.SERVER_URL }}
          AUTH_TOKEN: ${{ secrets.AUTH_TOKEN }}
        run: |
          echo "Uploading $BATCH_COUNT release archives..."
          
          upload_success=true
          
          # Upload each archive
          for i in $(seq 1 $BATCH_COUNT); do
            archive_file="release-$TAG-$i.zip"
            archive_hash_var="ARCHIVE_HASH_$i"
            archive_hash="${!archive_hash_var}"
            
            if [ -f "$archive_file" ] && [ ! -z "$archive_hash" ]; then
              echo "Uploading archive $i/$BATCH_COUNT: $archive_file with hash: $archive_hash"
              response=$(curl -s -X POST "$SERVER_URL/sessions/upload" \
                -H "Authorization: Bearer $AUTH_TOKEN" \
                -H "X-Upload-UUID: $SESSION_UUID" \
                -F "file=@$archive_file" \
                -F "hash=$archive_hash")
              echo "Response for archive $i: $response"
              
              # Check if upload was successful using jq
              if echo "$response" | jq -e '.success' > /dev/null 2>&1; then
                success=$(echo "$response" | jq -r '.success')
                if [ "$success" = "true" ]; then
                  echo "Successfully uploaded archive $i"
                else
                  error_msg=$(echo "$response" | jq -r '.error // "Unknown error"')
                  echo "Error uploading archive $i: $error_msg"
                  upload_success=false
                fi
              else
                echo "Error: Invalid response format for archive $i: $response"
                upload_success=false
              fi
            else
              echo "Error: Archive file $archive_file not found or hash not calculated"
              upload_success=false
            fi
          done
          
          if [ "$upload_success" = false ]; then
            echo "One or more uploads failed"
            exit 1
          fi
          
          echo "All $BATCH_COUNT archives uploaded successfully"

      - name: Upload summary
        run: |
          echo "Upload process completed for tag: $TAG"
          echo "Number of variants generated: $BATCH_COUNT"
          echo "Archives created:"
          for i in $(seq 1 $BATCH_COUNT); do
            archive_file="release-$TAG-$i.zip"
            archive_hash_var="ARCHIVE_HASH_$i"
            archive_hash="${!archive_hash_var}"
            echo "  $archive_file (hash: $archive_hash)"
            ls -lh "$archive_file"
          done
