import { minify } from "terser";
import { readFileSync, writeFileSync } from "fs";
import crypto from "crypto";

const banner = `THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin`;

const separate = (str) => new Set(str.split(" "));
const jsKeywords = separate(
	"break case catch class const continue debugger default delete do else enum export extends " +
		"false finally for function if import in instanceof new null return super switch this throw " +
		"true try typeof var void while with"
);
const jsStrictModeReservedWords = separate(
	"implements interface let package private protected public static yield"
);

class RandomNameGenerator {
	constructor(seed) {
		this.seed = seed || Date.now();
		this.counter = 0;
		this.usedNames = new Set();
	}

	generateName(length = 2) {
		const validChars =
			"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
		const validFirstChars =
			"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";

		let name;
		do {
			const hash = crypto
				.createHash("sha256")
				.update(`${this.seed}_${this.counter++}`)
				.digest("hex");

			const firstCharIndex =
				parseInt(hash.substring(0, 2), 16) % validFirstChars.length;
			name = validFirstChars[firstCharIndex];

			for (let i = 1; i < length; i++) {
				const hashStart = i * 2;
				const hashEnd = hashStart + 2;
				const charIndex =
					parseInt(hash.substring(hashStart, hashEnd), 16) %
					validChars.length;
				name += validChars[charIndex];
			}

			const maxNamesAtLength = Math.pow(validChars.length, length);
			const usageThreshold = maxNamesAtLength * 0.8;
			if (this.usedNames.size > usageThreshold) {
				length++;
				continue;
			}
		} while (this.usedNames.has(name) || this.isReserved(name));

		this.usedNames.add(name);
		return name;
	}

	isReserved(name) {
		return (
			jsKeywords.has(name) ||
			jsStrictModeReservedWords.has(name) ||
			name.startsWith("_")
		);
	}
}

function parseIdentities(identities, batchCount) {
	if (!identities || identities === "null") return null;
	try {
		const identityArray = identities.split(",").map((id) => id.trim());
		const filteredArray = identityArray.filter((id) => id.length > 0);
		if (filteredArray.length !== batchCount) {
			console.error(
				`Error: Number of identities (${filteredArray.length}) must match batch count (${batchCount})`
			);
			process.exit(1);
		}
		return filteredArray;
	} catch (error) {
		console.error("Error parsing identities:", error.message);
		process.exit(1);
	}
}

function generateSecureSeed(identity, tag, commitHash, suppliedNonce = null) {
	const nonce = suppliedNonce || crypto.randomBytes(16).toString("hex");
	const combined = identity + tag + commitHash + nonce;
	const seed = crypto.createHash("sha256").update(combined).digest("hex");
	return { seed, nonce };
}

function createBuildInfoBanner(identity, nonce, tag, commitHash) {
	return `/*
${banner}

BUILD INFO:
Identity: ${identity}
Tag: ${tag}
Commit: ${commitHash}
Nonce: ${nonce}
Generated: ${new Date().toISOString()}
*/`;
}

function generateSeedAndInfo(
	identity = "anonymous",
	tag = "unknown",
	commitHash = "unknown",
	suppliedNonce = null
) {
	// prettier-ignore
	const { seed, nonce } = generateSecureSeed(identity, tag, commitHash, suppliedNonce);
	const buildInfo = createBuildInfoBanner(identity, nonce, tag, commitHash);
	return { seed, buildInfo };
}

function getFileHash(code) {
	return crypto.createHash("sha256").update(code).digest("hex");
}

async function mangle(
	outputFilename = "dist/main.js",
	batchCount = 1,
	identities = null,
	tag = "unknown",
	commitHash = "unknown",
	suppliedNonce = null
) {
	const options = {
		mangle: {
			properties: false,
			toplevel: true,
		},
	};
	const code = readFileSync("dist/main.js", "utf8");
	const nameCache = {};
	await minify(code, { ...options, nameCache: nameCache });
	const results = [];
	const identityArray = parseIdentities(identities, batchCount);
	for (let i = 1; i <= batchCount; i++) {
		const filename = outputFilename.replace(/\.js$/, `-${i}.js`);
		const identity = identityArray ? identityArray[i - 1] : "anonymous";
		// prettier-ignore
		const info = generateSeedAndInfo(identity, tag, commitHash, suppliedNonce);
		const { seed, buildInfo } = info;
		const nameGenerator = new RandomNameGenerator(seed);
		for (const name of Object.keys(nameCache.vars.props)) {
			const newName = nameGenerator.generateName();
			nameCache.vars.props[name] = newName;
		}
		const result = await minify(code, { ...options, nameCache });
		const finalCode = buildInfo + "\n\n" + result.code;
		const hash = getFileHash(finalCode);
		writeFileSync(filename, finalCode);
		console.log(filename, hash);
		results.push({ filename, hash });
	}
	console.log(JSON.stringify(results));
	return results;
}

const outputFilename = process.argv[2] || "dist/main.js";
const batchCount = parseInt(process.argv[3]) || 1;
const identities = process.argv[4] || null;
const tag = process.argv[5] || "unknown";
const commitHash = process.argv[6] || "unknown";
const nonce = process.argv[7] || null;
mangle(outputFilename, batchCount, identities, tag, commitHash, nonce);
